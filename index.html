<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O Pequeno Miguel</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #007fff; /* Fundo do corpo */
            font-family: 'Press Start 2P', cursive;
        }
        #gameCanvas {
            border: 5px solid #6e6e6e;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: #ADD8E6; /* Cor de fallback */
        }
        
        /* Painel de Di√°logo */
        #messagePanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 450px;
            min-height: 100px;
            background-color: rgba(0, 0, 0, 0.95);
            border: 3px solid white;
            color: white;
            font-size: 16px;
            line-height: 1.5;
            text-align: center;
            padding: 15px;
            padding-bottom: 45px; /* Espa√ßo para o bot√£o */
            box-sizing: border-box;
            display: none; /* Inicia oculto */
            z-index: 100;
            cursor: default;
        }
        
        /* Estilos do Painel de Quiz */
        #quizPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 450px;
            min-height: 150px; 
            background-color: rgba(10, 10, 40, 0.98); 
            border: 3px solid #FFD700; 
            color: white;
            font-size: 16px;
            line-height: 1.5;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            display: none; /* Inicia oculto */
            z-index: 110; /* Acima do di√°logo */
            cursor: default;
        }

        #quizPanel .question-text {
            font-size: 18px;
            margin-bottom: 20px;
            color: #00FFFF;
        }

        #quizButtons {
            display: flex;
            justify-content: space-around;
            padding-top: 10px;
        }

        .quiz-button {
            background-color: #4CAF50; /* Cor padr√£o para SIM */
            color: white;
            border: 2px solid black;
            padding: 10px 20px;
            font-size: 16px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            box-shadow: 3px 3px 0px black;
            transition: background-color 0.1s;
        }
        .quiz-button:hover {
            background-color: #45a049;
        }
        .quiz-button.nao {
            background-color: #F44336; /* Cor para N√ÉO */
        }
        .quiz-button.nao:hover {
            background-color: #e53935;
        }


        /* Estilos dos √çcones de Di√°logo */
        #messagePanel img.icon-dialogue {
            position: absolute;
            top: -92px;
            left: 1px;
            width: 90px;
            height: auto;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
        }
        
        /* Estilo para o Nome do Falante */
        #messagePanel .speaker-name {
            color: #FFD700;
            font-size: 18px;
            margin-bottom: 5px;
            display: block;
            text-align: left;
            padding-left: 60px; /* Espa√ßo para o √≠cone */
        }
        
        /* Estilo para o Conte√∫do da Fala */
        #messagePanel .message-content {
            text-align: left; 
            padding-left: 60px;
        }
        
        /* Estilos do bot√£o Pr√≥ximo */
        #nextButton {
            background-color: #FFD700;
            color: black;
            border: 2px solid black;
            padding: 8px 15px;
            font-size: 14px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            position: absolute;
            bottom: 5px;
            right: 5px;
            box-shadow: 2px 2px 0px black;
        }
        #nextButton:hover {
            background-color: #FFA500;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="700"></canvas>
    <div id="messagePanel"></div>
    <div id="quizPanel"></div>
    
    <script>
        // --- CONFIGURA√á√ÉO INICIAL E CONSTANTES ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messagePanel = document.getElementById('messagePanel');
        const quizPanel = document.getElementById('quizPanel'); // Refer√™ncia ao novo painel do quiz
        
        const SCALE_FACTOR = 2;
        const CW = canvas.width;
        const CH = canvas.height;
        
        // Par√¢metros de f√≠sica
        const GRAVITY = 0.5 * SCALE_FACTOR;
        const JUMP_POWER = -11 * SCALE_FACTOR;
        const MOVE_SPEED = 3 * SCALE_FACTOR;
        
        // Par√¢metros visuais e de mundo
        const ANIMATION_SPEED = 5;
        const BODY_BOB = 2 * SCALE_FACTOR;
        const PARALLAX_FACTOR = 0.3;
        const PLATFORM_HEIGHT = 10 * SCALE_FACTOR;
        const PLATFORM_MIN_WIDTH = 50 * SCALE_FACTOR;
        const WORLD_GEN_THRESHOLD = CW * 0.1;
        
        // Comprimento do mundo (dist√¢ncia a percorrer)
        const WORLD_LENGTH_PHASE_1 = 10000 * SCALE_FACTOR;
        const GROUND_LEVEL_Y = 574;
        
        // --- VARI√ÅVEIS DE ESTADO DE DI√ÅLOGO E QUIZ ---
        let currentDialogue = null; 
        let currentLineIndex = 0; 
        let isDialogueRunning = false;
 
        // --- VARI√ÅVEIS DE ESTADO DE JOGO E TRANSI√á√ÉO ---
        let gameProgress = 0; // Contagem de itens coletados (0 a 10)
        let collectibles = [];
        let hasItemsBeenPlaced = false; // Flag para a coloca√ß√£o dos itens
        
        let camera = { x: 0, y: 0 };
        let score = 0;
        let startTime = 0;
        let elapsedTime = 0;
        let timerRunning = false;
        let isGameOver = false;

        // Vari√°veis para a Transi√ß√£o de Tela Final
        let isTransitioning = false;
        let transitionY = -CH; // Inicia fora da tela, acima
        const TRANSITION_SPEED = 20; 
        
        // Vari√°vel de estado para o di√°logo final
        let hasFinalDialogueRun = false; 

        // NOVO: O URL do background da fase final (75% - 100%) - ALT√âR√ÅVEL
        const FINAL_BACKGROUND_URL = 'https://uploads.onecompiler.io/43s2gnt72/442e8srt4/pixil-frame-0%20(20).png'; 

        // Cor da transi√ß√£o preta (mantida)
        const FINAL_SCREEN_COLOR = '#1A1A3A'; 

        // --- CONFIGURA√á√ÉO DO QUIZ ---
        const QUIZ_QUESTIONS = [
            // As respostas 'Sim' ou 'N√£o' abaixo s√£o o GABARITO.
            // Voc√™ pode mudar as perguntas e as respostas depois.
            { question: "Voc√™ acredita que, para fazer um amigo de verdade, √© preciso ter bastante paci√™ncia?", correct: "Sim" },
            { question: "Voc√™ j√° se sentiu triste quando um amigo foi embora, mesmo sabendo que ele voltaria?", correct: "Sim" },
            { question: "Voc√™ pensa que as coisas mais importantes da vida, como o amor e a amizade, podem ser vistas com os olhos?", correct: "N√£o" }, 
            { question: "Voc√™ concorda que um amigo se torna √∫nico no mundo para a gente, mesmo que existam outras pessoas parecidas com ele?", correct: "Sim" }
        ];

        let currentQuizIndex = 0;
        let quizScore = 0;
        let isQuizRunning = false;
        
        // --- DI√ÅLOGO FINAL ---
        const END_GAME_DIALOGUE = [ 
            { speaker: 'raposa', text: 'Sua jornada terminou. O que voc√™ cativou aqui o acompanhar√°. Para come√ßar uma nova aventura, voc√™ deve recarregar o seu caminho.' }
        ];

        // --- CONFIGURA√á√ÉO DOS ITENS COLET√ÅVEIS (10 ITENS) ---
        
        // URLs das imagens de itens (gen√©ricas)
        const PLAYER_IMAGE_URL = "https://uploads.onecompiler.io/43s2gnt72/43zhwdcza/1000112034.png";
        
        const COLLECTIBLE_IMAGE_URLS = {
            'principe': 'https://uploads.onecompiler.io/43s2gnt72/43zr2vkng/pixil-frame-0%20(10).png',
            'aviao': 'https://uploads.onecompiler.io/43s2gnt72/43zr2vkng/pixil-frame-0%20(11).png', // aviao
            'petala01': 'https://uploads.onecompiler.io/43s2gnt72/442b8p5em/petala1.png', // petala01
            'petala02': 'https://uploads.onecompiler.io/43s2gnt72/442b8p5em/petala2.png', // petala02
            'petala03': 'https://uploads.onecompiler.io/43s2gnt72/442b8p5em/petala3.png', // petala03
            'petala04': 'https://uploads.onecompiler.io/43s2gnt72/442b8p5em/petala4.png', // petala04
            'coroa': 'https://uploads.onecompiler.io/43s2gnt72/442bf3nn3/coroa.png', // coroa
            'garrafa': 'https://uploads.onecompiler.io/43s2gnt72/442bf3nn3/32504890-pixel-arte-ilustracao-cerveja-garrafa-pixelizada-cerveja-cerveja-garrafa-icone-pixelizada-para-a-pixel-arte-jogos-e-icone-para-local-na-rede-internet-e-video-jogo-velho-escola-retro-vetor-rem.png', // garrafa
            'papel': 'https://uploads.onecompiler.io/43s2gnt72/442bf3nn3/pixil-frame-0%20(13).png', // papel
            'livro': 'https://uploads.onecompiler.io/43s2gnt72/442bf3nn3/pixil-frame-0%20(15).png', // livro
            'raposa': 'https://uploads.onecompiler.io/43s2gnt72/442e8srt4/pixil-frame-0%20(21).png', // raposa (Final)
            'miguel_icon': 'https://uploads.onecompiler.io/43s2gnt72/442bf3nn3/pixil-frame-0%20(16).png', // √çcone do personagem principal
        };
        
        // Lista completa dos 10 itens com suas posi√ß√µes e **novos di√°logos estruturados**
        const COLLECTIBLE_ITEMS = [
            // { type: 'tipo', name: 'Nome do Item', progress: X%, dialogueLines: [{speaker: 'key', text: 'Fala'}], isFinal: false }
            
            // 1. aviao (Pequeno Pr√≠ncipe aparece)
            { 
                type: 'aviao', 
                name: 'rosa üåπ', 
                progress: 20, 
                dialogueLines: [
                    { speaker: 'miguel', text: 'Ao ver o avi√£o: Isso √© meio familiar...' },
                    { speaker: 'principe', text: 'Que engra√ßado! Achou o p√°ssaro de metal que perdi. Pode me ajudar a encontrar meus amigos?' },
                    { speaker: 'miguel', text: 'Ah, claro! Ser√° uma honra!' }
                ], 
                isFinal: false 
            },
            // 2. petala01
            { type: 'petala01', name: 'Flor üå∏', progress: 30, dialogueLines: [{ speaker: 'miguel', text: 'A primeira p√©tala! Sinto a For√ßa... √â o poder para continuar!' }], isFinal: false },
            // 3. petala02
            { type: 'petala02', name: 'Mapa üó∫Ô∏è', progress: 35, dialogueLines: [{ speaker: 'miguel', text: 'A segunda p√©tala! Estava escondida, exigindo Sabedoria para ser encontrada!' }], isFinal: false },
            // 4. petala03
            { type: 'petala03', name: 'Chave üîë', progress: 40, dialogueLines: [{ speaker: 'miguel', text: 'A terceira p√©tala me aquece. Ela √© o Amor, minha maior prote√ß√£o.' }], isFinal: false },
            // 5. petala04
            { type: 'petala04', name: 'Estrela ‚≠ê', progress: 45, dialogueLines: [{ speaker: 'miguel', text: 'A √∫ltima p√©tala! A Uni√£o est√° completa, o objetivo est√° ao meu alcance. Agora, vamos prosseguir com a nossa jornada' }], isFinal: false },
            // 6. coroa
            { type: 'coroa', name: 'Moeda ü™ô', progress: 55, dialogueLines: [{ speaker: 'miguel', text: 'Ele caminha at√© encontrar uma coroa: Pontiaguda e brilhante!' }], isFinal: false },
            // 7. garrafa
            { type: 'garrafa', name: 'Presente üéÅ', progress: 60, dialogueLines: [{ speaker: 'miguel', text: 'Seguindo seu caminho, ele encontra uma garrafa: Que cheiro forte.' }], isFinal: false },
            // 8. papel
            { type: 'papel', name: 'Globo Terrestre üåê', progress: 65, dialogueLines: [{ speaker: 'miguel', text: 'Ap√≥s isso, encontra um papel: Quantos n√∫meros!' }], isFinal: false },
            // 9. livro (Voz do Pr√≠ncipe)
            { 
                type: 'livro', 
                name: 'Lanterna üèÆ', 
                progress: 70, 
                dialogueLines: [
                    { speaker: 'miguel', text: 'Encontra um gigantesco livro: Apenas para exploradores, como sou um explorador, eu posso ler esse imenso livro!' },
                    { speaker: 'principe', text: '*A voz do pequeno pr√≠ncipe clama de longe* Finalmente encontrastes os adultos, vamos que precisamos encontrar a minha amiga raposa!' }
                ], 
                isFinal: false 
            },
            // 10. raposa (Di√°logo final - Precedido pelo Quiz)
            { 
                type: 'raposa', 
                name: 'Raposa (Final) ü¶ä', 
                progress: 99, 
                dialogueLines: [
                    { speaker: 'raposa', text: 'Ent√£o, voc√™ conseguiu. Voc√™ atravessou todos aqueles mundos. Os homens grandes teriam desistido. Eles n√£o t√™m tempo para o que realmente importa.' },
                    { speaker: 'miguel', text: 'Foi dif√≠cil. √Äs vezes eu me sentia muito sozinho.' },
                    { speaker: 'raposa', text: 'Mas voc√™ procurou com o cora√ß√£o. E s√≥ se v√™ bem com o cora√ß√£o. Voc√™ n√£o estava procurando apenas peda√ßos de papel, estava?' },
                    { speaker: 'miguel', text: 'Acho que estava procurando o sentido.' },
                    { speaker: 'raposa', text: 'E voc√™ o encontrou. Voc√™ cativou a hist√≥ria novamente. Voc√™ deu seu tempo a ela. E agora, ela √© importante para voc√™. E voc√™ √© importante para ela. Voc√™ se tornou respons√°vel por ela.'},
                    { speaker: 'raposa', text: 'Mas agora, pequeno viajante, seu tempo neste mundo acabou. Voc√™ n√£o pertence aqui. Este √© o mundo das mem√≥rias.'},
                    { speaker: 'raposa', text: 'Estou lhe dando o seu caminho de volta. Voc√™ n√£o pode ficar onde as coisas j√° terminaram. Voc√™ tem suas pr√≥prias coisas para cativar no seu mundo. Voc√™ tem suas pr√≥prias responsabilidades.'},
                    { speaker: 'miguel', text: 'Mas... e se eu esquecer?'},
                    { speaker: 'raposa', text: 'Voc√™ n√£o vai nos esquecer, ter√° boas lembran√ßas todas as vezes que olhar o teu livro.'},
                    { speaker: 'miguel', text: 'Eu vou sentir falta daqui.'},
                    { speaker: 'raposa', text: 'Isso √© bom. Significa que o que aconteceu foi real. Agora, feche os olhos. N√£o olhe para a partida. Pense apenas naquilo que espera por voc√™.'},
                    { speaker: 'miguel', text: 'Adeus, Raposa!'},
                    { speaker: 'raposa', text: 'Adeus! E lembre-se de n√≥s.'},
                ], 
                isFinal: true 
            } // Item final para terminar a fase
        ];
        
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // --- CARREGAMENTO DE IMAGENS E GEST√ÉO DE ASSETS ---
        
        const BACKGROUND_URLS = [
            'https://uploads.onecompiler.io/43s2gnt72/43zhwdcza/pixil-frame-0%20(6).png', 
            'https://uploads.onecompiler.io/43s2gnt72/43zr2vkng/pixil-frame-0%20(9).png', 
            'https://uploads.onecompiler.io/43s2gnt72/442bf3nn3/pixil-frame-0%20(18).png', 
            FINAL_BACKGROUND_URL // O √öLTIMO BACKGROUND AGORA √â DEFINIDO PELA CONSTANTE ACIMA
        ];
        
        const PLATFORM_TEXTURE_URL_PHASE_1 = 'https://uploads.onecompiler.io/43s2gnt72/43zhwdcza/pixil-frame-0%20(7).png';
        
        const backgroundImages = [];
        const collectibleImages = {};
        let backgroundLoadedCount = 0;
        let collectibleImagesLoadedCount = 0;
        let totalCollectibleImagesToLoad = 0;

        let currentBackground = null; 
        const platformTextureImage = new Image();
        let platformTextureLoaded = false;
        let playerImageLoaded = false;
        
        function checkAllAssetsLoaded() {
            if (backgroundLoadedCount === BACKGROUND_URLS.length && platformTextureLoaded 
                && playerImageLoaded && collectibleImagesLoadedCount === totalCollectibleImagesToLoad) {
                currentBackground = backgroundImages[0]; 
                loop(); 
            } else {
                setTimeout(checkAllAssetsLoaded, 100);
            }
        }

        function loadPhaseAssets() {
            const assetLoaded = (name) => { /* console.log(`${name} carregado.`); */ };

            // Carrega todos os backgrounds
            BACKGROUND_URLS.forEach((url, index) => {
                const img = new Image();
                img.onload = () => { backgroundLoadedCount++; assetLoaded(`Background ${index + 1}`); };
                img.onerror = () => { backgroundLoadedCount++; assetLoaded(`Background ${index + 1} (Error)`); };
                img.src = url;
                backgroundImages.push(img);
            });
            
            // Carrega imagens dos itens colet√°veis (incluindo 'miguel_icon')
            const uniqueCollectibleUrls = new Set(Object.values(COLLECTIBLE_IMAGE_URLS));
            totalCollectibleImagesToLoad = uniqueCollectibleUrls.size;

            uniqueCollectibleUrls.forEach(url => {
                const img = new Image();
                img.onload = () => { collectibleImagesLoadedCount++; assetLoaded(`Collectible Image ${url}`); };
                img.onerror = () => { collectibleImagesLoadedCount++; assetLoaded(`Collectible Image ${url} (Error)`); };
                img.src = url;
                // Mapeia a imagem para o tipo de item
                for (const type in COLLECTIBLE_IMAGE_URLS) {
                    if (COLLECTIBLE_IMAGE_URLS[type] === url) {
                        collectibleImages[type] = img;
                    }
                }
            });
            
            platformTextureImage.onload = () => { platformTextureLoaded = true; assetLoaded("Plat Texture"); };
            platformTextureImage.onerror = () => { platformTextureLoaded = true; assetLoaded("Plat Texture (Error)"); };
            platformTextureImage.src = PLATFORM_TEXTURE_URL_PHASE_1;

            // O objeto player carrega sua pr√≥pria imagem
            player.load(PLAYER_IMAGE_URL, () => {
                playerImageLoaded = true;
                assetLoaded("Player");
            });

            checkAllAssetsLoaded();
        }

        // --- OBJETO JOGADOR ---
        let player = {
            x: 50,
            y: GROUND_LEVEL_Y - 60 * SCALE_FACTOR,
            w: 48 * SCALE_FACTOR,
            h: 60 * SCALE_FACTOR,
            velX: 0,
            velY: 0,
            isJumping: false,
            frame: 0,
            frameTimer: 0,
            direction: 1, // 1 para direita, -1 para esquerda
            img: new Image(),
            imageLoaded: false,

            load: function(url, callback) {
                this.img.onload = () => { this.imageLoaded = true; if(callback) callback(); };
                this.img.onerror = () => { this.imageLoaded = true; if(callback) callback(); };
                this.img.src = url;
            },
            draw: function() {
                const px = this.x - camera.x;
                const py = this.y - camera.y;
                const pw = this.w;
                const ph = this.h;
                
                // Anima√ß√£o de "balan√ßo" (bob) do corpo ao andar
                let body_offset_y = (Math.abs(this.velX) > 0 && !this.isJumping && (this.frame === 0 || this.frame === 2)) ? BODY_BOB : 0;
                
                ctx.save();
                if (this.direction === -1) {
                    // Inverte a imagem horizontalmente
                    ctx.translate(px + pw / 2, 0);
                    ctx.scale(-1, 1);
                    ctx.translate(-(px + pw / 2), 0);
                }
                
                if (this.imageLoaded) {
                    // Desenha o sprite na posi√ß√£o correta, aplicando o offset do corpo
                    ctx.drawImage(this.img, px, py + body_offset_y, pw, ph - body_offset_y);
                } else {
                    // Fallback se a imagem n√£o carregar
                    ctx.fillStyle = '#FF4500';
                    ctx.fillRect(px, py + body_offset_y, pw, ph - body_offset_y);
                }
                ctx.restore();
            }
        };
        
        // --- ITENS COLET√ÅVEIS E DI√ÅLOGO ---
        
        function createCollectible(itemConfig, x, y) {
            const itemWidth = 30 * SCALE_FACTOR;
            const itemHeight = 30 * SCALE_FACTOR;
            return {
                x: x - itemWidth / 2, 
                y: y - itemHeight,
                w: itemWidth, 
                h: itemHeight, 
                isCollected: false, 
                config: itemConfig
            };
        }

        function drawCollectibles() {
            collectibles.forEach(item => {
                if (item.isCollected) return;

                const itemScreenX = item.x - camera.x;
                const itemScreenY = item.y - camera.y;
                const itemImage = collectibleImages[item.config.type];

                if (itemImage) {
                    // Efeito de brilho
                    ctx.save();
                    ctx.shadowColor = item.config.isFinal ? '#FFD700' : '#00FFFF'; // Amarelo para final, Ciano para outros
                    ctx.shadowBlur = 10;
                    ctx.drawImage(itemImage, itemScreenX, itemScreenY, item.w, item.h);
                    ctx.restore();
                } else {
                    // Fallback se a imagem n√£o carregar
                    ctx.fillStyle = item.config.isFinal ? '#FFD700' : '#00FFFF';
                    ctx.fillRect(itemScreenX, itemScreenY, item.w, item.h);
                }
            });
        }
        
        // Fun√ß√£o para mapear o 'speaker' do di√°logo ao nome de exibi√ß√£o e √≠cone
        function getSpeakerInfo(speakerKey, itemType) {
            const speakerMap = {
                'miguel': { name: 'Miguel', icon: 'miguel_icon' },
                // Usa o √≠cone do avi√£o para o Pequeno Pr√≠ncipe
                'principe': { name: 'P. Pr√≠ncipe', icon: 'principe' }, 
                'raposa': { name: 'Raposa', icon: 'raposa' },
            };
            
            // Retorna o mapeamento, ou um fallback usando o item coletado.
            return speakerMap[speakerKey] || { name: 'Desconhecido', icon: itemType };
        }

        function showCurrentLine() {
            if (!currentDialogue) return;

            const line = currentDialogue.dialogueLines[currentLineIndex];
            
            // Determine o √≠cone e o nome do falante
            let speakerInfo = getSpeakerInfo(line.speaker, currentDialogue.type);
            
            // L√≥gica para garantir os √≠cones corretos
            if (currentDialogue.type === 'raposa') {
                if (line.speaker === 'miguel') { speakerInfo.icon = 'miguel_icon'; }
                if (line.speaker === 'raposa') { speakerInfo.icon = 'raposa'; }
            }
            if (line.speaker === 'principe') {
                speakerInfo.icon = 'principe';
            }
            
            // Caso especial para o di√°logo final, se ele estiver rodando, exibe o √≠cone da raposa
            if (currentDialogue.dialogueLines === END_GAME_DIALOGUE) {
                 speakerInfo = { name: 'Raposa', icon: 'raposa' };
            }


            let contentHTML = '';
            const iconImage = collectibleImages[speakerInfo.icon];
            
            // Adiciona o √≠cone do falante
            if (iconImage) {  
                contentHTML += `<img src="${iconImage.src}" class="icon-dialogue">`;  
            }
            
            // Adiciona o nome do falante e o texto
            contentHTML += `<span class="speaker-name">${speakerInfo.name}:</span>`;
            contentHTML += `<div class="message-content">${line.text}</div>`;
            
            // Adiciona o bot√£o "Pr√≥ximo" ou "FIM"
            if (currentLineIndex < currentDialogue.dialogueLines.length - 1) {
                contentHTML += `<button id="nextButton" onclick="nextDialogueLine()">PR√ìXIMO</button>`;
            } else {
                // √öltima fala: o bot√£o fechar√° o painel
                contentHTML += `<button id="nextButton" onclick="nextDialogueLine()">FECHAR</button>`;
            }

            messagePanel.innerHTML = contentHTML;
            messagePanel.style.display = 'block';

            isDialogueRunning = true;
        }

        // A nova fun√ß√£o global para avan√ßar o di√°logo
        function nextDialogueLine() {
            if (!currentDialogue) return;

            currentLineIndex++;

            if (currentLineIndex < currentDialogue.dialogueLines.length) {
                showCurrentLine();
            } else {
                // Di√°logo terminado
                messagePanel.style.display = 'none';
                isDialogueRunning = false;
                currentDialogue = null;
                currentLineIndex = 0;
                
                // Se o √∫ltimo item foi coletado, inicia a transi√ß√£o final
                if (collectibles.length > 0 && collectibles[collectibles.length - 1].isCollected) {
                    startTransition();
                }
            }
        }
        
        // Fun√ß√£o para iniciar o Di√°logo Final (Chamado ap√≥s a transi√ß√£o preta)
        function startFinalDialogue() { 
            // Usa o sistema de di√°logo existente com uma configura√ß√£o final.
            const finalDialogueConfig = {
                type: 'raposa', 
                name: 'Raposa', 
                dialogueLines: END_GAME_DIALOGUE,
                isFinal: true 
            };
            
            // Reutiliza a l√≥gica de inicializa√ß√£o de di√°logo
            currentDialogue = finalDialogueConfig;
            currentLineIndex = 0;
            showCurrentLine();
        }

        // Fun√ß√£o para iniciar a Transi√ß√£o
        function startTransition() {
            if (isTransitioning || isGameOver) return;
            isTransitioning = true;
            timerRunning = false; // Para o cron√¥metro
        }

        function startDialogue(itemConfig) { 
            if (isDialogueRunning || isQuizRunning || isTransitioning) return; // Garante que n√£o inicie se o quiz estiver rodando

            if (Array.isArray(itemConfig.dialogueLines) && itemConfig.dialogueLines.length > 0) {
                currentDialogue = itemConfig;
                currentLineIndex = 0;
                showCurrentLine();
            } 
        }
        
        // --- L√ìGICA DO QUIZ ---
        
        // Fun√ß√£o para iniciar o Quiz
        function startQuiz(itemConfig) {
            if (isQuizRunning || isDialogueRunning || isTransitioning) return;

            // Resetar o estado do quiz
            currentQuizIndex = 0;
            quizScore = 0;
            isQuizRunning = true;
            currentDialogue = itemConfig; // Armazena a configura√ß√£o para o di√°logo p√≥s-quiz

            showCurrentQuestion();
        }

        // Fun√ß√£o para exibir a pergunta atual
        function showCurrentQuestion() {
            if (!isQuizRunning) return;
            
            const questionData = QUIZ_QUESTIONS[currentQuizIndex];
            let contentHTML = '';

            // Adiciona o t√≠tulo e a pergunta
            contentHTML += `<span class="speaker-name" style="text-align: center; padding-left: 0; display: block; margin-bottom: 10px;">QUIZ FINAL (Pergunta ${currentQuizIndex + 1}/${QUIZ_QUESTIONS.length})</span>`;
            contentHTML += `<div class="question-text">${questionData.question}</div>`;
            
            // Adiciona os bot√µes de resposta
            contentHTML += `<div id="quizButtons">`;
            // Note: answerQuestion precisa estar no escopo global para funcionar no onclick
            contentHTML += `<button class="quiz-button" onclick="answerQuestion('Sim')">SIM</button>`;
            contentHTML += `<button class="quiz-button nao" onclick="answerQuestion('N√£o')">N√ÉO</button>`;
            contentHTML += `</div>`;
            
            quizPanel.innerHTML = contentHTML;
            quizPanel.style.display = 'block';
        }

        // Fun√ß√£o chamada ao clicar em "Sim" ou "N√£o"
        window.answerQuestion = function(answer) {
            if (!isQuizRunning) return;
            
            const questionData = QUIZ_QUESTIONS[currentQuizIndex];
            
            // Verifica a resposta
            if (answer === questionData.correct) {
                quizScore++;
            }
            
            currentQuizIndex++;
            
            // Verifica se o quiz terminou
            if (currentQuizIndex < QUIZ_QUESTIONS.length) {
                // Pr√≥xima pergunta
                showCurrentQuestion();
            } else {
                // Fim do quiz
                endQuiz();
            }
        }

        // Fun√ß√£o chamada ao final do quiz
        function endQuiz() {
            quizPanel.style.display = 'none';
            isQuizRunning = false;
            
            // Mensagem do resultado
            let finalMessage = `Voc√™ demonstrou que absorveu ${quizScore*25}% do mundo do Pequeno Miguel.`;
            
            // Cria uma nova primeira linha com o resultado, dita pelo Pequeno Pr√≠ncipe
            const resultLine = { 
                speaker: 'principe', 
                text: `√ìtimo! ${finalMessage} Agora podemos conversar com a Raposa e terminar a jornada!` 
            };

            // Insere o resultado antes do di√°logo original da Raposa
            const originalDialogue = currentDialogue.dialogueLines;
            const newDialogueLines = [resultLine, ...originalDialogue];
            
            // Inicia o di√°logo final com a Raposa (usando as novas linhas)
            startDialogue({
                type: currentDialogue.type,
                name: currentDialogue.name,
                dialogueLines: newDialogueLines,
                isFinal: currentDialogue.isFinal
            });
        }


        // --- PLATAFORMAS E GERA√á√ÉO DO MUNDO ---
        
        let platforms = [
            // Plataforma inicial (ch√£o)
            {x: 0, y: GROUND_LEVEL_Y, w: CW * 1000, h: 1, isGround: true},
        ];

        let lastPlatformX = 0;
        let lastPlatformY = GROUND_LEVEL_Y;
        
        /**
         * Coloca todos os itens colet√°veis nas plataformas ou no ch√£o
         * quando a gera√ß√£o atinge o ponto X do item.
         */
        function placeCollectibleItems() {
             if (hasItemsBeenPlaced) return;

            // Ordena os itens para garantir que sejam colocados em ordem crescente de X
            const sortedItems = COLLECTIBLE_ITEMS.sort((a, b) => a.progress - b.progress);

            sortedItems.forEach(itemConfig => {
                const targetX = (WORLD_LENGTH_PHASE_1 * itemConfig.progress) / 100;
                
                // Encontra a plataforma mais pr√≥xima e √† esquerda ou que cubra o targetX
                let bestPlatform = platforms[0]; // Come√ßa com o ch√£o

                // Procura a plataforma mais pr√≥xima antes ou sobre o targetX
                for (let i = 1; i < platforms.length; i++) {
                    const p = platforms[i];
                    if (p.x < targetX) {
                        bestPlatform = p;
                    }
                    // Se a plataforma cruzar o targetX, usamos ela
                    if (p.x + p.w >= targetX && p.x < targetX) {
                        bestPlatform = p;
                        break;
                    }
                }

                // Posiciona o item no centro da plataforma (ou na posi√ß√£o X alvo se for o ch√£o)
                let itemX = targetX;
                let itemY = bestPlatform.y;

                if (!bestPlatform.isGround) {
                    itemX = bestPlatform.x + bestPlatform.w / 2;
                }
                
                // Garante que o item n√£o se sobreponha a um j√° existente (opcional, mas bom)
                const isOverlapping = collectibles.some(
                    c => Math.abs(c.x - itemX) < c.w * 1.5 // Dist√¢ncia m√≠nima entre itens
                );

                if (!isOverlapping) {
                    collectibles.push(createCollectible(itemConfig, itemX, itemY));
                }
            });

            hasItemsBeenPlaced = true;
        }

        function generateRandomPlatforms() {
             // Chamada √∫nica para garantir a coloca√ß√£o dos itens
             if (lastPlatformX >= WORLD_LENGTH_PHASE_1 * 0.99 && !hasItemsBeenPlaced) {
                 placeCollectibleItems(); 
             }
            
            // Se o mundo j√° tiver sido completamente percorrido
            if (lastPlatformX >= WORLD_LENGTH_PHASE_1) {
                return;
            }
            
            const remainingWidth = WORLD_LENGTH_PHASE_1 - lastPlatformX;
            const generationWidth = Math.min(CW * 1.5, remainingWidth);
            
            if (generationWidth <= 0) {
                return;
            }

            const MAX_PLATFORM_WIDTH = 100 * SCALE_FACTOR;
            const MIN_GAP = player.w * 0.8;
            const MAX_GAP = player.w * 2.3; 
            
            let currentX = lastPlatformX;
            
            while (currentX < lastPlatformX + generationWidth && currentX < WORLD_LENGTH_PHASE_1) {
                
                const gap = getRandomInt(MIN_GAP, MAX_GAP);
                const nextX = currentX + gap;
                
                if (nextX >= WORLD_LENGTH_PHASE_1) break;

                const pWidth = getRandomInt(PLATFORM_MIN_WIDTH, MAX_PLATFORM_WIDTH);
                const actualPWidth = Math.min(pWidth, WORLD_LENGTH_PHASE_1 - nextX);
                
                if (actualPWidth < PLATFORM_MIN_WIDTH / 2) {
                    lastPlatformX = WORLD_LENGTH_PHASE_1;
                    break;
                }
                
                const MAX_Y_CHANGE = 120 * SCALE_FACTOR;
                const MIN_PLATFORM_HEIGHT_FROM_GROUND = 80 * SCALE_FACTOR;
                const JUMP_HEIGHT = JUMP_POWER * -1.5;

                const y_min = player.h * 2;
                const y_max = GROUND_LEVEL_Y - PLATFORM_HEIGHT - MIN_PLATFORM_HEIGHT_FROM_GROUND;
                const maxUpY = lastPlatformY - JUMP_HEIGHT; 

                // Determina uma nova altura razo√°vel
                let newY = getRandomInt(
                    Math.max(y_min, lastPlatformY - MAX_Y_CHANGE, maxUpY),
                    Math.min(y_max, lastPlatformY + MAX_Y_CHANGE)
                );
                
                platforms.push({x: nextX, y: newY, w: actualPWidth, h: PLATFORM_HEIGHT, isGround: false});

                lastPlatformY = newY;
                currentX = nextX + actualPWidth;
                lastPlatformX = currentX;
            }
            
            // Remove plataformas antigas que sa√≠ram da tela para otimizar
            platforms = platforms.filter(p => p.isGround || p.x + p.w > camera.x - CW);
            
            // Se a gera√ß√£o alcan√ßou um ponto de item, tente coloc√°-lo (principalmente para o ch√£o)
            if (!hasItemsBeenPlaced) {
                 COLLECTIBLE_ITEMS.forEach(itemConfig => {
                    const targetX = (WORLD_LENGTH_PHASE_1 * itemConfig.progress) / 100;
                    if (lastPlatformX >= targetX) {
                        placeCollectibleItems();
                    }
                });
            }
        }

        generateRandomPlatforms(); // Gera plataformas iniciais

        // --- UPDATE (Game Logic) e INPUTS ---

        let keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (!isGameOver && !isDialogueRunning && !isQuizRunning && !isTransitioning && (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') && !player.isJumping) {
                player.velY = JUMP_POWER;
                player.isJumping = true;
            }
        });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });
        
        function checkCollision(obj1, obj2) {
            return (obj1.x < obj2.x + obj2.w && obj1.x + obj1.w > obj2.x && obj1.y < obj2.y + obj2.h && obj1.y + obj1.h > obj2.y);
        }

        function update() {
            
            // [MODIFICADO] L√≥gica da Transi√ß√£o
            if (isTransitioning) {
                if (transitionY < 0) {
                    transitionY += TRANSITION_SPEED;
                } else {
                    transitionY = 0; 
                    isTransitioning = false;
                    isGameOver = true; // Transi√ß√£o completa
                    
                    // Inicia o di√°logo final assim que a tela preta desce
                    if (!hasFinalDialogueRun) {
                        startFinalDialogue();
                        hasFinalDialogueRun = true;
                    }
                }
                return; // Bloqueia o update do jogo enquanto transiciona
            }

            // Para o jogo se o jogo acabou, o di√°logo est√° rodando OU O QUIZ EST√Å RODANDO
            if (isGameOver || isDialogueRunning || isQuizRunning) { 
                 if (timerRunning) elapsedTime = performance.now() - startTime;
                 return; 
            }
            
            let movementX = 0;
            player.velX = 0;
            
            if (keys['ArrowLeft'] || keys['KeyA']) { movementX = -MOVE_SPEED; player.velX = -MOVE_SPEED; player.direction = -1; }
            if (keys['ArrowRight'] || keys['KeyD']) { movementX = MOVE_SPEED; player.velX = MOVE_SPEED; player.direction = 1; }

            // Inicia o cron√¥metro no primeiro movimento
            if (!timerRunning && (Math.abs(movementX) > 0 || keys['Space'] || keys['ArrowUp'] || keys['KeyW'])) {
                startTime = performance.now();
                timerRunning = true;
            }
            if (timerRunning) { elapsedTime = performance.now() - startTime; }

            // Anima√ß√£o de corrida
            if (Math.abs(player.velX) > 0 && !player.isJumping) {
                player.frameTimer++;
                if (player.frameTimer >= ANIMATION_SPEED) { player.frameTimer = 0; player.frame = (player.frame + 1) % 3; }
            } else { player.frame = 1; player.frameTimer = 0; } // P√°ra na pose "parado"

            // Aplica gravidade e movimento
            player.velY += GRAVITY;
            player.y += player.velY;
            player.x += movementX;
            
            // Limites do mundo (X)
            if (player.x < 0) { player.x = 0; player.velX = 0; }
            if (player.x + player.w >= WORLD_LENGTH_PHASE_1) { player.x = WORLD_LENGTH_PHASE_1 - player.w; player.velX = 0; }
            
            // C√¢mera segue o jogador, mantendo-o um pouco √† esquerda
            camera.x = player.x - 50;
            
            // Gatilho para gera√ß√£o de plataformas
            if (player.x > lastPlatformX - CW + WORLD_GEN_THRESHOLD || lastPlatformX < WORLD_LENGTH_PHASE_1) { 
                generateRandomPlatforms(); 
            }
            
            // Colis√µes com plataformas (apenas pela parte de cima)
            platforms.forEach(p => {
                const isFalling = player.velY >= 0;
                const isAbove = player.y + player.h <= p.y + player.velY; 
                
                if (player.x + player.w > p.x && player.x < p.x + p.w && isAbove && player.y + player.h >= p.y && isFalling) {
                    player.y = p.y - player.h; 
                    player.velY = 0; 
                    player.isJumping = false;
                }
            });
            
            // Colis√£o com o ch√£o (ground level)
            if (player.y + player.h > GROUND_LEVEL_Y && player.velY >= 0) {
                player.y = GROUND_LEVEL_Y - player.h; 
                player.velY = 0; 
                player.isJumping = false;
            }
            
            // Se cair muito abaixo (Morte/Respawn)
            if (player.y > CH * 2) { 
                player.x = camera.x + 100; 
                player.y = GROUND_LEVEL_Y - player.h; 
                player.velY = 0; 
                player.isJumping = false; 
                camera.y = 0; 
            }
            
            // Colis√£o com Itens Colet√°veis
            collectibles.forEach(item => {
                if (item.isCollected) return;

                const itemWorld = { x: item.x, y: item.y, w: item.w, h: item.h };
                const playerWorld = { x: player.x, y: player.y, w: player.w, h: player.h };
                
                if (checkCollision(playerWorld, itemWorld)) {
                    item.isCollected = true;
                    score++;
                    gameProgress++; // Aumenta o contador de progresso
                    
                    // Se for o item 'raposa' (final), inicia o QUIZ
                    if (item.config.type === 'raposa') {
                        startQuiz(item.config); // Inicia o quiz
                    } else {
                        startDialogue(item.config); // Inicia o di√°logo
                    }
                }
            });
        }

        // --- DRAW (Renderiza√ß√£o) ---

        function formatTime(ms) {
            const totalSeconds = ms / 1000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const milliseconds = Math.floor((totalSeconds % 1) * 100);
            const pad = (num, size = 2) => ('000' + num).slice(size * -1);
            return `${pad(minutes)}:${pad(seconds)}.${pad(milliseconds)}`;
        }
        
        // Fun√ß√£o para obter o background com base na posi√ß√£o do jogador
        function getBackgroundByProgress() {
            if (backgroundImages.length === 0) return null;
            
            const progress = player.x / WORLD_LENGTH_PHASE_1;
            
            // Seleciona o BG correto com base no progresso (0-25%, 25-50%, 50-75%, 75-100%)
            if (progress >= 0.75) {
                return backgroundImages[3]; 
            } else if (progress >= 0.50) {
                return backgroundImages[2]; 
            } else if (progress >= 0.25) {
                return backgroundImages[1]; 
            } else {
                return backgroundImages[0];
            }
        }

        function drawBackground() {
            currentBackground = getBackgroundByProgress();
            
            if (!currentBackground || !currentBackground.width) {
                ctx.fillStyle = '#ADD8E6';
                ctx.fillRect(0, 0, CW, CH);
                return;
            }

            const bgW = currentBackground.width;
            const bgH = currentBackground.height;
            const ratio = Math.max(CW / bgW, CH / bgH);
            const destW = bgW * ratio;
            const destH = CH;
            
            // Calcula o offset do parallax
            let bgOffset = (camera.x * PARALLAX_FACTOR) % destW;
            if (bgOffset < 0) bgOffset += destW;
            
            // Desenha duas c√≥pias para criar um loop cont√≠nuo
            ctx.drawImage(currentBackground, 0, 0, bgW, bgH, -bgOffset, 0, destW, destH);
            ctx.drawImage(currentBackground, 0, 0, bgW, bgH, -bgOffset + destW, 0, destW, destH);
        }

        function draw() {
            ctx.clearRect(0, 0, CW, CH);
            
            // 1. Background
            drawBackground();

            // 2. Plataformas
            platforms.forEach(p => {
                // Desenha apenas as plataformas n√£o-ch√£o
                if (!p.isGround) {
                    const screenX = p.x - camera.x;
                    const screenY = p.y - camera.y;
                    if (screenX + p.w > 0 && screenX < CW) {
                        if (platformTextureLoaded) {
                            ctx.drawImage(platformTextureImage, screenX, screenY, p.w, p.h);
                        } else {
                            ctx.fillStyle = '#888888';
                            ctx.fillRect(screenX, screenY, p.w, p.h);
                        }
                    }
                }
            });

            // 3. Itens Colet√°veis
            drawCollectibles();

            // 4. Jogador
            player.draw();

            // 5. HUD
            
            // Fun√ß√£o auxiliar de texto (AGORA COM SUPORTE A BORDA)
            const drawText = (text, x, y, size = 12, color = 'white', strokeColor = null, lineWidth = 0) => {
                ctx.font = `${size}px "Press Start 2P", cursive`;
                
                // Desenha a borda (stroke) se as configura√ß√µes forem fornecidas
                if (strokeColor && lineWidth > 0) {
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    ctx.strokeText(text, x, y);
                }

                // Desenha o preenchimento (fill)
                ctx.fillStyle = color;
                ctx.fillText(text, x, y);
            };
                

            // Desenha o HUD apenas se o jogo n√£o estiver na tela final ou transicionando
            if (!isGameOver && !isTransitioning) {
                drawText(`TEMPO: ${formatTime(elapsedTime)}`, 10, 25, 20, 'white', 'black', 3);
                drawText('SETAS/AD: ANDAR | ESPA√áO/W: PULAR', 10, 50, 20, 'white', 'black', 3);
                
                const progress = Math.min(100, Math.floor(player.x / WORLD_LENGTH_PHASE_1 * 100));
                drawText(`PROGRESSO: ${progress}%`, 10, 75, 20, 'white', 'black', 3);
                
                const section = progress >= 75 ? 4 : progress >= 50 ? 3 : progress >= 25 ? 2 : 1;
                drawText(`Planeta em que estou: ${section}¬∫ Planeta`, 10, 105, 20, 'white', 'black', 3);

                drawText(`ITENS COLETADOS: ${gameProgress} / ${COLLECTIBLE_ITEMS.length}`, 10, 135, 20, 'white', 'black', 3);
            }
            
            // [NOVA L√ìGICA DE TRANSI√á√ÉO E TELA FINAL]
            if (isGameOver || isTransitioning) {
                ctx.save();
                
                // Determina a posi√ß√£o Y da tela final/transi√ß√£o (animada)
                let screenY = isTransitioning ? transitionY : 0;
                
                // 1. Fundo da Transi√ß√£o (Cor escura mantida)
                ctx.fillStyle = FINAL_SCREEN_COLOR; 
                ctx.fillRect(0, screenY, CW, CH);

                ctx.textAlign = 'left';
                ctx.restore();
            }
        }

        // --- GAME LOOP ---
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }
        
        // Inicia o carregamento dos assets
        loadPhaseAssets();
    </script>
</body>
</html>
